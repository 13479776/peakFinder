visible(text133) = FALSE
} else {
addHandlerChanged(radio131, handler=changetest)
}
frame14 = gframe("View mode of the matching tab",container = group11, horizontal = FALSE)
check141 = gcheckboxgroup(c("Matched variables","Partial-matched variables","Unmatched variables"), checked = TRUE, container = frame14, handler = changematching)
#####----------------------------------------------#####
##  In the second tab we can:                         ##
##  (1) Switch the variable names in the same gtable. ##
##  (2) Go back or go forth or reset the matching.    ##
#####----------------------------------------------#####
group21 = ggroup(horizontal = FALSE, container = tab, label = "Matching", expand = T)
group22 = ggroup(container = group21, use.scrollwindow = TRUE, expand = T)
group2 = list()
gt2 <- list()
mergegui_env$hstry1 <- list()
mergegui_env$hstry1[[1]] <- nametable
mergegui_env$name_intersection_panel <- data.frame(
Namecode=rownames(nametable),
Variables=nameintersect,
Class=var.class(nametable,dataset),
stringsAsFactors = FALSE)
if (unit) mergegui_env$name_intersection_panel$Unit = scale_rpart(nametable,dataset,nameintersect)
if (distn) mergegui_env$name_intersection_panel$Dist = scale_kstest(nametable,dataset,nameintersect)
if (miss) mergegui_env$name_intersection_panel$Miss = scale_missing(nametable,dataset,nameintersect)
mergegui_env$hstry2 <- list()
mergegui_env$hstry2[[1]] <- mergegui_env$name_intersection_panel
Matched = substr(rownames(nametable),5,regexpr('-',rownames(nametable))-1)
FileMatched = as.character((n+1)-as.integer(Matched))
mergegui_env$hstry3 <- list()
mergegui_env$hstry3[[1]] <- data.frame(mergegui_env$name_intersection_panel[,1:3],FileMatched)
mergegui_env$hstry4 <- list()
mergegui_env$hstry4[[1]] <- 1
mergegui_env$idx <- 1
mergegui_env$redo.indicate <- 0
for (i in 1:n) {
group2[[i]] = ggroup(horizontal = FALSE, container = group22,
expand = T)
gt2[[i]] <- gtable(data.frame(namecode=rownames(nametable),nametable[, i, drop = F],stringsAsFactors = FALSE), chosencol = 2, container = group2[[i]], expand = TRUE)
addHandlerKeystroke(gt2[[i]], handler = function(h,...){})
tag(gt2[[i]], "prev.idx") <- svalue(gt2[[i]], index = TRUE)
tag(gt2[[i]], "toggle") <- FALSE
tag(gt2[[i]], "idx") <- i
addhandlerclicked(gt2[[i]], handler = function(h, ...) {
gt.tmp = h$obj
prev.idx = tag(gt.tmp, "prev.idx")
gt.tmp.svalue = paste(svalue(gt.tmp))
if (length(prev.idx) == 1 && tag(gt.tmp, "toggle") &&
length(gt.tmp.svalue)>0 &&
gt.tmp.svalue!=paste(gt.tmp[prev.idx, 2])) {
tmp = gt.tmp[prev.idx, 2]
gt.tmp[prev.idx, 2] = svalue(gt.tmp)
gt.tmp[svalue(gt.tmp, index = TRUE), 2] = tmp
mergegui_env$idx <- mergegui_env$idx + 1
mergegui_env$hstry1[[mergegui_env$idx]] <- mergegui_env$hstry1[[mergegui_env$idx - 1]]
mergegui_env$hstry1[[mergegui_env$idx]][, tag(gt.tmp, "idx")] <- gt.tmp[,2]
if (tag(gt.tmp, "idx") == 1) {
tmpgt4 = mergegui_env$gt4[mergegui_env$gt4[,1]==gt2[[i]][prev.idx,1], 2:3]
mergegui_env$gt4[mergegui_env$gt4[,1]==gt2[[i]][prev.idx,1], 2:3] = mergegui_env$gt4[mergegui_env$gt4[,1]==gt2[[i]][svalue(gt.tmp, index = TRUE),1], 2:3]
mergegui_env$gt4[mergegui_env$gt4[,1]==gt2[[i]][svalue(gt.tmp, index = TRUE),1], 2:3] = tmpgt4
}
mergegui_env$gt5[, 2] <- mergegui_env$gt4[order(mergegui_env$gt4[,1]), 2]
mergegui_env$gt5[, 3] <- mergegui_env$gt4[order(mergegui_env$gt4[,1]), 3]
mergegui_env$hstry2[[mergegui_env$idx]] <- mergegui_env$gt4[,]
mergegui_env$hstry3[[mergegui_env$idx]] <- mergegui_env$gt5[,]
if (length(svalue(check141))==3) {mergegui_env$hstry4[[mergegui_env$idx]] <- mergegui_env$idx} else {mergegui_env$hstry4[[mergegui_env$idx]] <- mergegui_env$hstry4[[mergegui_env$idx-1]]}
mergegui_env$redo.indicate <- 0
}
tag(gt.tmp, "toggle") = !tag(gt.tmp, "toggle")
tag(gt.tmp, "prev.idx") = svalue(gt.tmp, index = TRUE)
})
}
group23 <- ggroup(container = group21)
gbcombo21 <- gbutton("Undo", container = group23, handler = undo,
expand = TRUE)
gbcombo22 <- gbutton("Redo", container = group23, handler = redo,
expand = TRUE)
gbcombo23 <- gbutton("Reset", container = group23, handler = reset,
expand = TRUE)
#####------------------------------------------------#####
##  In the third tab we can:                            ##
##  (1) Watch and change the name or type of variables. ##
##  (2) Numeric or graphic summary.                     ##
##  (3) Dictionary for factor variables.                ##
#####------------------------------------------------#####
group41 = ggroup(container = tab, label = "Summary", expand = T)
mergegui_env$group42 <- ggroup(container = group41, use.scrollwindow = TRUE, expand = T)
mergegui_env$gt4 <- gtable(mergegui_env$name_intersection_panel, multiple = T, container = mergegui_env$group42, expand = TRUE, chosencol = 2)
addhandlerdoubleclick(mergegui_env$gt4, handler = VariableOptions)
mergegui_env$group43 <- ggroup(horizontal = FALSE, container = group41,
expand = TRUE)
group44 = ggroup(horizontal = TRUE, container = mergegui_env$group43)
gbcombo431 <- gbutton("Numeric summary", container = group44,
handler = smmry, expand = TRUE)
gbcombo432 <- gbutton("Graphical summary", container = group44,
handler = graph, expand = TRUE)
gbcombo433 <- gbutton("Dictionary", container = group44, handler = dict,
expand = TRUE)
mergegui_env$group45 <- ggroup(container = mergegui_env$group43, expand = TRUE, use.scrollwindow = TRUE)
#####------------------------------------------------#####
##  In the fourth tab we can:                           ##
##  (1) Select all or none variables.                   ##
##  (2) Export the data.                                ##
#####------------------------------------------------#####
group51 = ggroup(container = tab, label = "Export", expand = T)
group52 = ggroup(container = group51, use.scrollwindow = TRUE,
expand = T)
mergegui_env$gt5 <- gtable(data.frame(mergegui_env$name_intersection_panel[,1:3],FileMatched), multiple = T, container = group52,
expand = TRUE, chosencol = 2)
addhandlerclicked(mergegui_env$gt5,handler=function(h,...){
svalue(gbcombo57) = paste("Currently you select",length(svalue(mergegui_env$gt5)),"variables.",sep=" ")
})
group53 = ggroup(horizontal = FALSE, container = group51,
expand = TRUE)
gbcombo51 <- gbutton("Select All", container = group53, handler = function(h,
...) {
svalue(mergegui_env$gt5, index = TRUE) = 1:length(nameintersect)
svalue(gbcombo57) = paste("Currently you select all",length(nameintersect),"variables.",sep=" ")
focus(mergegui_env$gt5)
})
gbcombo52 <- gbutton("Clear All", container = group53, handler = function(h,
...) {
svalue(mergegui_env$gt5) = NULL
svalue(gbcombo57) = "Currently you select 0 variable."
})
gbcombo55 <- gbutton("Export the matched data", container = group53,
handler = watchdatafunc)
gbcombo56 <- glabel(paste("The complete merged data have ",sum(rows)," rows and ",
length(nameintersect)," columns."),container=group53)
gbcombo57 <- glabel(paste("Currently you select 0 variable."),container=group53)
svalue(tab)=1
}
mergeID = function(h, ...) {
####################################################
# mergeID is a function to merge the observations. #
####################################################
watchIDfunc = function(h, ...) {
#####------------------------------------------------------------------------------------#####
##  watchIDfunc is a function to export the merged dataset.                                 ##
##  key is a vector of the selected primary keys. We checked the validity of the key first. ##
##  keyID is the merged ID for the observations.                                            ##
##  mergeIDdata is the matrix that merged all the files by the keyID.                       ##
##  We should write 'xxx.csv' when we export mergeIDdata and save the file.                 ##
#####------------------------------------------------------------------------------------#####
keyID = c()
vcolumn = rep(0, n)
key = c()
for (i in 1:n) {
key[i] = svalue(gt3[[i]])
if (sum(duplicated(as.character(dataset[[i]][, key[i]]))) >
0) {
gmessage(paste(key[i], "could not be the primary key for",
basename(gtfile[i]), "because it has repeated items. Please choose another key."))
return()
}
keyID = union(keyID, dataset[[i]][, key[i]])
vcolumn[i] = length(vname[[i]]) - 1
}
mergeIDdata = matrix(NA, nrow = length(keyID), ncol = sum(vcolumn) +
1, dimnames = list(keyID))
mergeIDdata[, 1] = keyID
mergeIDcolnames = c(key[1], 1:sum(vcolumn) + 1)
for (i in 1:n) {
mergeIDdata[as.character(dataset[[i]][, key[i]]),
cumsum(c(2, vcolumn))[i]:cumsum(c(1, vcolumn))[i +
1]] = as.matrix(dataset[[i]][, setdiff(vname[[i]],
key[i])])
mergeIDcolnames[cumsum(c(2, vcolumn))[i]:cumsum(c(1,
vcolumn))[i + 1]] = paste(basename(gtfile[i]),
".", colnames(dataset[[i]][, setdiff(vname[[i]],
key[i])]), sep = "")
}
colnames(mergeIDdata) = mergeIDcolnames
if (!is.na(gf <- gfile(type = "save"))) {
if (regexpr("\\.csv$",gf) %in% c(-1,1)) {
write.csv(mergeIDdata, file = paste(gf,".csv",sep=""), row.names = FALSE)
} else {
write.csv(mergeIDdata, file = gf, row.names = FALSE)
}
gmessage("The files are merged!")
}
}
dataset <- list()
vname <- list()
simplifiedname <- list()
if (length(svalue(gt)) == 0) {
n <- length(gt[])
gtfile <- gt[]
}
else {
n <- length(svalue(gt))
gtfile <- svalue(gt)
}
rows <- rep(0, n)
for (i in 1:n) {
dataset[[i]] <- if (length(grep("\\.csv$",gtfile[i]))) {
read.csv(file = gtfile[i], header = T)
} else { gtdata[[i]] }
rows[i] <- nrow(dataset[[i]])
vname[[i]] <- colnames(dataset[[i]])
J = gregexpr(".csv.", vname[[i]])
loc = c()
for (j in 1:length(vname[[i]])) {
loc[j] = max(J[[j]]) + 5
}
loc[which(loc == 4)] = 1
simplifiedname[[i]] = substring(vname[[i]], loc)
}
a = intersect2(vname, simplifiedname)
tmpuniq = a$uniq
tmpnametable = a$individual
tmpvname = list()
for (i in 1:n) {
tmpvname[[i]] = c(tmpnametable[, i], tmpuniq[[i]])
}
#####-----------------------------------------#####
##  In this GUI we can:                          ##
##  Select the primary keys for different files. ##
#####-----------------------------------------#####
combo3 <- gwindow("Matched Primary Key", visible = TRUE)
group3 <- ggroup(horizontal = FALSE, container = combo3)
gt3 <- list()
for (i in 1:n) {
gl3 = glabel(paste("Select the Primary Key from", basename(gtfile[i])),
container = group3)
gt3[[i]] <- gcombobox(tmpvname[[i]], container = group3,
expand = T)
}
gbcombo3 = gbutton("Match by the Key", container = group3,
handler = watchIDfunc)
}
#####---------------------#####
##  First GUI:  Open files.  ##
#####---------------------#####
gtdata=list(...)
mycall <- as.list(match.call()[-1])
if (!missing(filenames)) mycall <- mycall[names(mycall)!='filenames']
if (!missing(unit)) mycall <- mycall[names(mycall)!='unit']
if (!missing(distn)) mycall <- mycall[names(mycall)!='distn']
if (!missing(miss)) mycall <- mycall[names(mycall)!='miss']
datasets = as.character(unlist(mycall))
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group,
handler = mergefunc)
gb3 <- gbutton("Match by the Key", container = group,
handler = mergeID)
}
group2 <- ggroup(horizontal = T, container = combo)
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group,
handler = mergefunc)
gb3 <- gbutton("Match by the Key", container = group,
handler = mergeID)
group2 <- ggroup(horizontal = T, container = combo)
gb1 <- gbutton("Open", container = group2, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group,
handler = mergefunc)
gb3 <- gbutton("Match by the Key", container = group,
handler = mergeID)
group2 <- ggroup(horizontal = T, container = combo)
gb4 <- gbutton("Open", container = group2, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group
)
gb3 <- gbutton("Match by the Key", container = group
)
group2 <- ggroup(horizontal = T, container = combo)
gb4 <- gbutton("Open", container = group2, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group
)
gb3 <- gbutton("Match by the Key", container = group
)
group2 <- ggroup(horizontal = T, container = combo)
gt <- gtable(f.list, multiple = T, container = group2, expand = TRUE)
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group
)
gb3 <- gbutton("Match by the Key", container = group
)
group2 <- ggroup(horizontal = T, container = combo)
gt2 <- gtable(f.list, multiple = T, container = group2, expand = TRUE)
combo3 <- gwindow("Matched Primary Key", visible = TRUE)
group3 <- ggroup(horizontal = FALSE, container = combo3)
gt3 <- list()
for (i in 1:n) {
gl3 = glabel(paste("Select the Primary Key from", basename(gtfile[i])),
container = group3)
gt3[[i]] <- gcombobox(tmpvname[[i]], container = group3,
expand = T)
}
gbcombo3 = gbutton("Match by the Key", container = group3,
handler = watchIDfunc)
}
combo3 <- gwindow("Matched Primary Key", visible = TRUE)
group3 <- ggroup(horizontal = FALSE, container = combo3)
gt3 <- list()
for (i in 1:n) {
gl3 = glabel(paste("Select the Primary Key from", basename(gtfile[i])),
container = group3)
gt3[[i]] <- gcombobox(tmpvname[[i]], container = group3,
expand = T)
}
gbcombo3 = gbutton("Match by the Key", container = group3,
handler = watchIDfunc)
}
#####---------------------#####
##  First GUI:  Open files.  ##
#####---------------------#####
gtdata=list(...)
mycall <- as.list(match.call()[-1])
if (!missing(filenames)) mycall <- mycall[names(mycall)!='filenames']
if (!missing(unit)) mycall <- mycall[names(mycall)!='unit']
if (!missing(distn)) mycall <- mycall[names(mycall)!='distn']
if (!missing(miss)) mycall <- mycall[names(mycall)!='miss']
datasets = as.character(unlist(mycall))
combo <- gwindow("Combination", visible = TRUE)
group <- ggroup(horizontal = FALSE, container = combo)
if (is.null(filenames) & is.null(datasets)) {
f.list <- matrix(nrow = 0, ncol = 1, dimnames = list(NULL, "File"))
} else {
f.list <- matrix(c(datasets,filenames), ncol = 1, dimnames = list(NULL, "File"))
}
gt <- gtable(f.list, multiple = T, container = group, expand = TRUE)
gb1 <- gbutton("Open", container = group, handler = function(h, ...) gt[,] = union(gt[,],na.omit(gfile(multiple=TRUE))))
gb2 <- gbutton("Match the Variables", container = group,handler =
)
gb3 <- gbutton("Match by the Key", container = group
)
group2 <- ggroup(horizontal = T, container = combo)
gt2 <- gtable(f.list, multiple = T, container = group2, expand = TRUE)
install.packages('JGR',,'http://www.rforge.net/')
sourceFile <- function() gfile("Select a file",type="open", handler =
function(h,...) source(h$file))
source(gfile(filter=c("R files"="R")))
## apply a generic action to the file
countLines <- function(filename) print(length(readLines(filename)))
chooseFile <- function() gfile("Select a file",type="open",
action="countLines", handler = function(h,...) do.call(h$action,list(h$file)))
library(gWidgets)
source(gfile(filter=c("R files"="R")))
## apply a generic action to the file
countLines <- function(filename) print(length(readLines(filename)))
chooseFile <- function() gfile("Select a file",type="open",
action="countLines", handler = function(h,...) do.call(h$action,list(h$file)))
source(gfile(filter=c("R files"="R")))
## apply a generic action to the file
countLines <- function(filename) print(length(readLines(filename)))
chooseFile <- function() gfilebrowse("Select a file",type="open",
action="countLines", handler = function(h,...) do.call(h$action,list(h$file)))
source(gfile(filter=c("R files"="R")))
## apply a generic action to the file
countLines <- function(filename) print(length(readLines(filename)))
chooseFile <- function() gcalendar("Select a file",type="open",
action="countLines", handler = function(h,...) do.call(h$action,list(h$file)))
getWidget <- function(x, cont=cont) {
+   switch(class(x),
+
+
+
+
+
+
+ +) +}
getWidget <- function(x, cont=cont) {
+   switch(class(x),"numeric" = gedit(x, coerce.with=as.numeric, cont=cont),
"character" = gcombobox(x, active=1, cont=cont),
"logical" = gcombobox(c(TRUE,FALSE), active = 1 + (x == FALSE), cont=con
"name" = gedit("", cont=cont),
"NULL" = gedit("NULL", cont=cont),
"call" = getWidget(eval(x), cont=cont), # recurse
gedit("", cont=cont)                     # default
}
?file.edit
file.edit("script1.R", "script2.R")
filefile.show(file.path(R.home("doc"), "COPYRIGHTS"))
file.show(file.path(R.home("doc"), "COPYRIGHTS"))
library(raster)
?raster
r <- raster(system.file("external/test.grd", package="raster"))
r
image(r)
require(grDevices) # for colours
x <- y <- seq(-4*pi, 4*pi, len = 27)
r <- sqrt(outer(x^2, y^2, "+"))
image(z = z <- cos(r^2)*exp(-r/6), col  = gray((0:32)/32))
image(z, axes = FALSE, main = "Math can be beautiful ...",
xlab = expression(cos(r^2) * e^{-r/6}))
contour(z, add = TRUE, drawlabels = FALSE)
m = matrix(runif(100),10,10)
par(mar=c(0, 0, 0, 0))
image(m, useRaster=TRUE, axes=FALSE)
m
op <- par(bg = "thistle")
plot(c(100, 250), c(300, 450), type = "n", xlab = "", ylab = "")
image <- as.raster(matrix(0:1, ncol = 5, nrow = 3))
rasterImage(image, 100, 300, 150, 350, interpolate = FALSE)
x <- c(1:9, 8:1)
y <- c(1, 2*(5:3), 2, -1, 17, 9, 8, 2:9)
op <- par(mfcol = c(3, 1))
for(xpd in c(FALSE, TRUE, NA)) {
plot(1:10, main = paste("xpd =", xpd))
box("figure", col = "pink", lwd = 3)
polygon(x, y, xpd = xpd, col = "orange", lty = 2, lwd = 2, border = "red")
}
n <- 100
xx <- c(0:n, n:0)
yy <- c(c(0, cumsum(stats::rnorm(n))), rev(c(0, cumsum(stats::rnorm(n)))))
plot   (xx, yy, type = "n", xlab = "Time", ylab = "Distance")
polygon(xx, yy, col = "gray", border = "red")
library(ggmap)
library(raster)
library(maptools)
library(plyr)
install_github("fdetsch/ggmap", ref = "develop")
devtools::install_github("fdetsch/ggmap", ref = "develop")
map_world <- get_map(location = "world")
library(ggmap)
map_world <- get_map(location = "world")
library(apLCMS)
? bigauss.mix
?? bigauss.mix
?prof.to.features
data(prof)
?prof.to.features
con <- socketConnection(port = 79, blocking = TRUE)
writeLines(paste0(system("whoami", intern = TRUE), "\r"), con)
gsub(" *$", "", readLines(con))
close(con)
setwd("~/Documents/software/R/peakTarget/data")
load("xcms.HPLC.Orbi.RData")
names(targetPara)
targetPara
class(targetPara)
class(platformPara) == "list"
platformPara <- targetPara
class(platformPara) == "list"
platformPara <- "HTOF"
class(platformPara)
?data
setwd("~/Documents/software/R/peakTarget/R")
library(devtools)
load_all()
document()
document()
xx <- peakTarget(platformPara = "uori")
?peakTarget
document()
xx <- peakTarget(platformPara = "uorbi")
library()
library(xcms)
library(CAMERA)
xx <- peakTarget(platformPara = "uorbi")
yx <- peakTarget(platformPara = "htof")
setwd("~/Documents/software/R/peakTarget/inst/parameters")
para <- readPKparam("inhouse.pk.param.csv")
yx <- peakTarget(platformPara = para)
"Para"
load_all()
yx <- peakTarget(platformPara = para)
yx <- peakTarget(platformPara)
yx <- peakTarget(platformPara = "uorbi")
yx <- peakTarget(platformPara = para)
